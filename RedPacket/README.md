# RedPacket
redis 实现并发抢红包

## 乐观锁
### 原理：
大多数是基于数据版本（version）的记录机制实现的。
即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个”version”字段来实现读取出数据时，将此版本号一同读出，之后更新时，对此版本号加1。此时，将提交数据的版本号与数据库表对应记录的当前版本号进行比对，如果提交的数据版本号大于数据库当前版本号，则予以更新，否则认为是过期数据。redis中可以使用watch命令会监视给定的key，当exec时候如果监视的key从调用watch后发生过变化，则整个事务会失败。也可以调用watch多次监视多个key。这样就可以对指定的key加乐观锁了。注意watch的key是对整个连接有效的，事务也一样。
如果连接断开，监视和事务都会被自动清除。当然了exec，discard，unwatch命令都会清除连接中的所有监视。

### 细节：
1.redis 存储红包数量totalnum,红包金额money,抢到红包用户set集合
2.判断用户是否抢过
3.判断红包是否有剩余
4.开始抢红包，红包数减一，随机产生一个红包金额，更新剩余红包金额，更新抢到红包的用户set集合。

## Redis事务
Redis中的事务(transaction)是一组命令的集合。事务同命令一样都是Redis最小的执行单位，一个事务中的命令要么都执行，要么都不执行。Redis事务的实现需要用到 MULTI 和 EXEC 两个命令，事务开始的时候先向Redis服务器发送 MULTI 命令，然后依次发送需要在本次事务中处理的命令，最后再发送 EXEC 命令表示事务命令结束。Redis的事务是下面4个命令来实现 

1. multi，开启Redis的事务，置客户端为事务态。
2. exec，提交事务，执行从multi到此命令前的命令队列，置客户端为非事务态。
3. discard，取消事务，置客户端为非事务态。
4. watch,监视键值对，作用时如果事务提交exec时发现监视的监视对发生变化，事务将被取消。

## 乐观锁存在的问题
1.红包会无法领取完。也就是秒杀的库存遗留问题。

## 使用Lua脚本
###发红包：
1.红包数(totalnum) 红包金额(totalmoney) 
2.将红包安装红包数划分为数组：红包数组(moneyls)
3.将上面的totalnum,totalmoney,moneyls 存储在redis中
4.使用set存储抢到红包用户列表
###抢红包
1.检查set集合是否有这个用户，保证用户只能抢一次 抢过返回
2.检查红包数是否有剩余 没有返回
3.开始抢红包，totalnum-1，push一个红包，然后金额totalmoney更新
4.使用lua脚本完成上面的操作
5.redis加载lua脚本并执行
